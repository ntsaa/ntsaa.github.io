<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Network — Fix</title>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      background: radial-gradient(circle at center, #0d1b2a, #000);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial;
      color: #fff;
      overflow: hidden;
    }

    /* Canvas phải nằm trên background để nhìn thấy, nhưng không chặn click (pointer-events:none) */
    canvas#network {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;               /* <= visible */
      pointer-events: none;     /* không chặn nội dung */
      display: block;
    }

    .content {
      position: relative;
      z-index: 2;
      height: 100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap: 12px;
    }

    h1 { color: #00c3ff; text-shadow: 0 0 12px rgba(0,195,255,0.35); margin: 0; font-size: 2.6rem;}
    p { margin: 0; opacity: 0.9; }

    /* Hộp trạng thái nhỏ ở góc để debug nhanh */
    #status {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 3;
      background: rgba(0,0,0,0.45);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
      color: #bfefff;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <canvas id="network" aria-hidden="true"></canvas>

  <div class="content">
    <h1>Particle Network</h1>
    <p>HTML + CSS + JS — phiên bản đã sửa lỗi (debug)</p>
  </div>

  <div id="status">Init...</div>

  <script>
    (function () {
      const status = document.getElementById('status');
      const canvas = document.getElementById('network');

      // Try get context
      let ctx;
      try {
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('2D context unavailable');
      } catch (err) {
        status.textContent = 'Canvas 2D not supported';
        console.error('Canvas init error:', err);
        return;
      }

      console.log('Canvas 2D OK');

      // DPR handling for crisp rendering
      const DPR = window.devicePixelRatio || 1;
      function resize() {
        // style size (CSS pixels)
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        // internal size (actual pixels)
        canvas.width = Math.max(1, Math.floor(window.innerWidth * DPR));
        canvas.height = Math.max(1, Math.floor(window.innerHeight * DPR));
        // reset transform so 1 unit = 1 CSS pixel
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        // update globals used by script
        w = window.innerWidth;
        h = window.innerHeight;
      }
      window.addEventListener('resize', resize);

      // Particle system
      let w = window.innerWidth, h = window.innerHeight;
      const num = 80;
      const particles = [];
      const maxDist = 130;

      function initParticles() {
        particles.length = 0;
        for (let i = 0; i < num; i++) {
          particles.push({
            x: Math.random() * w,
            y: Math.random() * h,
            vx: (Math.random() - 0.5) * 1.4,
            vy: (Math.random() - 0.5) * 1.4,
            r: 1.5 + Math.random() * 1.8
          });
        }
      }

      // Mouse
      const mouse = { x: null, y: null, radius: 150 };
      window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });
      window.addEventListener('mouseleave', () => {
        mouse.x = null;
        mouse.y = null;
      });

      // Animation loop
      let rafId = null;
      function animate() {
        ctx.clearRect(0, 0, w, h);

        // move & draw particles
        for (const p of particles) {
          p.x += p.vx;
          p.y += p.vy;

          if (p.x <= 0 || p.x >= w) p.vx *= -1;
          if (p.y <= 0 || p.y >= h) p.vy *= -1;

          // mouse repulse
          if (mouse.x !== null) {
            const dx = p.x - mouse.x;
            const dy = p.y - mouse.y;
            const dist = Math.hypot(dx, dy);
            if (dist < mouse.radius && dist > 0.001) {
              const ang = Math.atan2(dy, dx);
              const push = (mouse.radius - dist) / mouse.radius;
              p.vx += Math.cos(ang) * push * 0.45;
              p.vy += Math.sin(ang) * push * 0.45;
            }
          }

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = '#00c3ff';
          ctx.fill();
        }

        // connections
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const a = particles[i], b = particles[j];
            const dx = a.x - b.x, dy = a.y - b.y;
            const d = Math.hypot(dx, dy);
            if (d < maxDist) {
              const alpha = (1 - d / maxDist) * 0.55;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.strokeStyle = `rgba(0,195,255,${alpha})`;
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }

        rafId = requestAnimationFrame(animate);
      }

      // Start everything
      try {
        resize();
        initParticles();
        animate();
        status.textContent = 'Running';
        console.log('Particle animation started');
      } catch (err) {
        status.textContent = 'Error';
        console.error('Animation start error:', err);
      }

      // Expose for debug (optional)
      window.__particleDebug = { canvas, ctx, particles, resize, initParticles };

    })();
  </script>
</body>
</html>
